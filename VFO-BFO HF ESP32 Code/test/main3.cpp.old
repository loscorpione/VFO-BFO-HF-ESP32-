#include <Arduino.h>
#include <Wire.h>
#include <si5351.h>
#include <TFT_eSPI.h>

// Configurazione encoder
#define ENC_CLK 34
#define ENC_DT  35
#define ENC_SW  32
#define SW_BAND 33    // Pin per selezione banda

// Configurazione I2C
#define I2C_SDA 21
#define I2C_SCL 22

// Configurazione display
TFT_eSPI tft = TFT_eSPI();

// Variabili encoder
int encoderPos = 0;
int lastEncoded = 0;
int encoderCount = 0; // Contatore per gestire 2 step per scatto

// Variabili frequenza
unsigned long frequency = 7000000; // 7.0 MHz
unsigned long step = 1000;         // 1 kHz step
unsigned long minFreq = 1000000;   // 1 MHz
unsigned long maxFreq = 30000000;  // 30 MHz

// Struttura per les bande
struct Band {
  const char* name;
  unsigned long startFreq;
  unsigned long endFreq;
};

// Definizione delle bande radioamatoriali
Band bands[] = {
  {"160m", 1830000, 1850000},    // 160 metri (1.83-1.85 MHz)
  {"80m", 3500000, 3800000},     // 80 metri (3.5-3.8 MHz)
  {"60m", 5351000, 5366000},     // 60 metri (5.351-5.366 MHz)
  {"40m", 7000000, 7200000},     // 40 metri (7.0-7.2 MHz)
  {"30m", 10100000, 10150000},   // 30 metri (10.1-10.15 MHz)
  {"20m", 14000000, 14350000},   // 20 metri (14.0-14.35 MHz)
  {"17m", 18068000, 18168000},   // 17 metri (18.068-18.168 MHz)
  {"15m", 21000000, 21450000},   // 15 metri (21.0-21.45 MHz)
  {"12m", 24890000, 24990000},   // 12 metri (24.89-24.99 MHz)
  {"10m", 28000000, 29700000}    // 10 metri (28.0-29.7 MHz)
};

int currentBandIndex = 3; // Inizia sulla banda 40m (indice 3)
int totalBands = sizeof(bands) / sizeof(bands[0]); // Numero totale di bande

// Oggetto SI5351
Si5351 si5351;

// Variabili per debounce
unsigned long lastEncoderRead = 0;
const int encoderReadInterval = 10; // ms
unsigned long lastButtonPress = 0;
unsigned long lastBandButtonPress = 0;
const int buttonDebounce = 200;     // ms
bool buttonPressed = false;
bool bandButtonPressed = false;

// Prototipi funzioni
void readEncoder();
void updateFrequency();
void changeStep();
void updateFrequencyDisplay();
void updateStepDisplay();
void updateBandInfo();
String formatFrequency(unsigned long freq);
void drawDisplayLayout();
int getBandIndex(unsigned long freq);
void changeBand();

// Colori personalizzati
#define FREQUENCY_COLOR TFT_GREEN
#define STEP_COLOR TFT_RED
#define BAND_COLOR TFT_CYAN
#define BACKGROUND_COLOR TFT_BLACK
#define BORDER_COLOR TFT_WHITE

void setup() {
  Serial.begin(115200);
  delay(1000);
  Serial.println("SI5351 VFO Controller - ESP32");
  Serial.println("=================================");

  // Inizializzazione display
  Serial.println("Initializing ili9341 display...");
  tft.init();
  tft.setRotation(1);
  tft.fillScreen(BACKGROUND_COLOR);
  
  // Disegna il layout iniziale
  drawDisplayLayout();
  updateFrequencyDisplay();
  updateStepDisplay();
  updateBandInfo();

  // Configurazione encoder e pulsanti
  pinMode(ENC_CLK, INPUT_PULLUP);
  pinMode(ENC_DT, INPUT_PULLUP);
  pinMode(ENC_SW, INPUT_PULLUP);
  pinMode(SW_BAND, INPUT_PULLUP); // Pulsante banda
  
  // Lettura stato iniziale encoder
  lastEncoded = (digitalRead(ENC_DT) << 1) | digitalRead(ENC_CLK);

  // Inizializzazione I2C
  Serial.println("Initializing i2c..."); 
  Wire.begin(I2C_SDA, I2C_SCL);
  delay(100);

  // Inizializzazione SI5351
  Serial.println("Initializing SI5351...");
  if (si5351.init(SI5351_CRYSTAL_LOAD_8PF, 0, 0) == false) {
    Serial.println("ERROR: SI5351 not found!");
    tft.setTextColor(TFT_RED, BACKGROUND_COLOR);
    tft.drawString("SI5351 ERROR", 80, 120);
    while(1) {
      delay(1000);
      Serial.print(".");
    }
  }
  
  Serial.println("SI5351 found and initialized");

  // Configurazione SI5351
  si5351.set_pll(SI5351_PLL_FIXED, SI5351_PLLA);
  si5351.drive_strength(SI5351_CLK0, SI5351_DRIVE_8MA);
  si5351.output_enable(SI5351_CLK0, 1);
  
  // Imposta frequenza iniziale
  si5351.set_freq(frequency * 100ULL, SI5351_CLK0);
  
  Serial.println("Setup completed");
}

void loop() {
  // Lettura encoder
  readEncoder();

  // Cambio step con pulsante encoder
  if (digitalRead(ENC_SW) == LOW && !buttonPressed) {
    if (millis() - lastButtonPress > buttonDebounce) {
      buttonPressed = true;
      changeStep();
      lastButtonPress = millis();
      updateStepDisplay();
      delay(300); // Feedback tattile
    }
  }
  
  // Reset del flag quando il pulsante encoder viene rilasciato
  if (digitalRead(ENC_SW) == HIGH && buttonPressed) {
    buttonPressed = false;
  }

  // Cambio banda con pulsante banda
  if (digitalRead(SW_BAND) == LOW && !bandButtonPressed) {
    if (millis() - lastBandButtonPress > buttonDebounce) {
      bandButtonPressed = true;
      changeBand();
      lastBandButtonPress = millis();
      updateFrequencyDisplay();
      updateBandInfo();
      delay(300); // Feedback tattile
    }
  }
  
  // Reset del flag quando il pulsante banda viene rilasciato
  if (digitalRead(SW_BAND) == HIGH && bandButtonPressed) {
    bandButtonPressed = false;
  }
}

void readEncoder() {
  int MSB = digitalRead(ENC_CLK);
  int LSB = digitalRead(ENC_DT);

  int encoded = (MSB << 1) | LSB;
  int sum = (lastEncoded << 2) | encoded;

  if (sum == 0b1101 || sum == 0b0100 || sum == 0b0010 || sum == 0b1011) {
    encoderCount++;
    if (encoderCount >= 2) { // 2 step per scatto
      frequency += step;
      if (frequency > maxFreq) frequency = maxFreq;
      updateFrequency();
      updateFrequencyDisplay();
      updateBandInfo(); // Aggiorna la banda quando cambia la frequenza
      encoderCount = 0;
    }
  }
  else if (sum == 0b1110 || sum == 0b0111 || sum == 0b0001 || sum == 0b1000) {
    encoderCount++;
    if (encoderCount >= 2) { // 2 step per scatto
      frequency -= step;
      if (frequency < minFreq) frequency = minFreq;
      updateFrequency();
      updateFrequencyDisplay();
      updateBandInfo(); // Aggiorna la banda quando cambia la frequenza
      encoderCount = 0;
    }
  }

  lastEncoded = encoded;
  delayMicroseconds(100);
}

void updateFrequency() {
  // Aggiorna SI5351
  si5351.set_freq(frequency * 100ULL, SI5351_CLK0);
  
  // Debug su seriale
  Serial.print("Frequency: ");
  Serial.print(frequency);
  Serial.print(" Hz (Step: ");
  Serial.print(step);
  Serial.println(" Hz)");
}

void changeStep() {
  switch(step) {
    case 10: 
      step = 100;     // 100 Hz
      break;
    case 100: 
      step = 1000;    // 1 kHz
      break;
    case 1000: 
      step = 10000;   // 10 kHz
      break;
    case 10000: 
      step = 10;      // 10 Hz
      break;
    default:
      step = 1000;
  }
  
  Serial.print("Step changed to: ");
  Serial.print(step);
  Serial.println(" Hz");
}

void changeBand() {
  // Passa alla banda successiva
  currentBandIndex = (currentBandIndex + 1) % totalBands;
  
  // Imposta solo la frequenza all'inizio della banda, SENZA cambiare i limiti
  frequency = bands[currentBandIndex].startFreq;
  
  // Aggiorna SI5351
  updateFrequency();
  
  Serial.print("Band changed to: ");
  Serial.println(bands[currentBandIndex].name);
}

int getBandIndex(unsigned long freq) {
  for (int i = 0; i < totalBands; i++) {
    if (freq >= bands[i].startFreq && freq <= bands[i].endFreq) {
      return i;
    }
  }
  return -1; // Nessuna banda trovata
}

void drawDisplayLayout() {
  // Riquadro principale frequenza (in alto) - Arrotondato
  tft.fillRoundRect(5, 5, 230, 90, 10, BACKGROUND_COLOR);
  tft.drawRoundRect(5, 5, 230, 90, 10, BORDER_COLOR);
  tft.drawRoundRect(6, 6, 228, 88, 10, BORDER_COLOR);
  
  // Riquadro step (in basso a destra) - Arrotondato
  tft.fillRoundRect(240, 55, 75, 35, 8, BACKGROUND_COLOR);
  tft.drawRoundRect(240, 55, 75, 35, 8, BORDER_COLOR);
  tft.drawRoundRect(241, 56, 73, 33, 8, BORDER_COLOR);
  
  // Riquadro banda (in basso a sinistra) - Arrotondato
  tft.fillRoundRect(5, 100, 65, 40, 5, BACKGROUND_COLOR);
  tft.drawRoundRect(5, 100, 65, 40, 5, BORDER_COLOR);
  
  // Etichetta Frequency
  tft.setTextColor(TFT_WHITE, BACKGROUND_COLOR);
  tft.setTextSize(1);
  tft.drawString("FREQUENCY", 10, 15);
  
  // Etichetta Step
  tft.drawString("STEP", 250, 40);
  
  // Etichetta Band
  tft.drawString("BAND", 10, 108);
}

void updateFrequencyDisplay() {
  // Aggiorna solo la frequenza
  String freqStr = formatFrequency(frequency);
  
  tft.fillRect(10, 30, 220, 55, BACKGROUND_COLOR);
  tft.setTextColor(FREQUENCY_COLOR, BACKGROUND_COLOR);
  tft.setTextSize(4);
  
  // Centra la frequenza nel riquadro
  int textWidth = freqStr.length() * 24;
  int xPos = 10 + (220 - textWidth) / 2;
  if (xPos < 10) xPos = 10;
  tft.drawString(freqStr, xPos, 35);
}

void updateStepDisplay() {
  // Aggiorna solo lo step
  tft.fillRoundRect(245, 60, 65, 25, 5, BACKGROUND_COLOR);
  tft.setTextColor(STEP_COLOR, BACKGROUND_COLOR);
  tft.setTextSize(2);
  
  String stepStr;
  if (step == 10) stepStr = "10Hz";
  else if (step == 100) stepStr = "100Hz";
  else if (step == 1000) stepStr = "1kHz";
  else if (step == 10000) stepStr = "10kHz";
  
  // Centra lo step nel riquadro
  int textWidth = stepStr.length() * 12;
  int xPos = 245 + (65 - textWidth) / 2;
  tft.drawString(stepStr, xPos, 63);
}

void updateBandInfo() {
  // Determina la banda corrente in base alla frequenza
  int bandIndex = getBandIndex(frequency);
  
  // Aggiorna il display con info banda
  tft.fillRect(7, 118, 60, 15, BACKGROUND_COLOR);
  tft.setTextColor(BAND_COLOR, BACKGROUND_COLOR);
  tft.setTextSize(2);
  
  if (bandIndex >= 0) {
    tft.drawString(bands[bandIndex].name, 15, 118);
    currentBandIndex = bandIndex; // Aggiorna l'indice della banda corrente
  } else {
    tft.drawString("--", 25, 118); // Nessuna banda trovata
  }
}

String formatFrequency(unsigned long freq) {
  String result;
  
  if (freq >= 1000000) {
    // Formato MHz: XXX.XXX.XX (5 decimali con punto separatore)
    unsigned long mhz = freq / 1000000;
    unsigned long hz = freq % 1000000;
    
    // Prima parte: XXX.XXX
    unsigned long khz_part = hz / 1000;  // Parte in kHz
    unsigned long hz_part = hz % 1000;   // Parte in Hz (ultimi 3 digit)
    
    result = String(mhz) + ".";
    
    // Aggiungi zeri leading per kHz
    if (khz_part < 100) result += "0";
    if (khz_part < 10) result += "0";
    result += String(khz_part);
    
    // Aggiungi punto separatore e parte Hz (solo prime 2 cifre)
    result += ".";
    unsigned short last_two_digits = hz_part / 10; // Prendi solo le prime 2 cifre dei Hz
    if (last_two_digits < 10) result += "0";
    result += String(last_two_digits);
    
  } else {
    // Formato kHz: XXXXX.XX (2 decimali)
    unsigned long khz = freq / 1000;
    unsigned long hz = freq % 1000;
    
    result = String(khz) + ".";
    unsigned short decimal_part = hz / 10; // Solo 2 decimali
    if (decimal_part < 10) result += "0";
    result += String(decimal_part);
  }
  
  return result;
}